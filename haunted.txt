10. Haunted
The king of ghosts is really disappointed when he sees that all the human beings on
Planet Earth have stopped fearing the ghost race. He knows the reason for this. The
existing ghost race has become really lazy and has stopped visiting Planet Earth to
scare the human race. Hence, he decides to encourage the entire ghost race into
scaring the humans by holding a competition. The king, however, never visits Planet
Earth.
This competition will go on for N days. Currently, there are a total of M ghosts (apart
from the king) existing in the ghost race such that :
- The youngest ghost is 1 year old.
- The oldest ghost is M years old.
- No two ghosts have the same age.
- The age of each and every ghost is a positive integer.
On each day of the competition, ghosts have to visit Planet Earth to scare people. At
the end of each day, a "Ghost of the Day" title is awarded to the ghost who scares the
most number of humans on that particular day. However, the king of ghosts believes
in consistency. Once this title has been given, the ghost who has won the most
number of such titles until that particular moment is presented with a "Consistency
Trophy". If there are many such ghosts, the oldest among them is given the trophy.
Note that this "Title Giving" and "Trophy Giving" happens at the end of each day of
the competition.
You will be given the age of the ghost who won the "Ghost of the Day" title on each
day of the competition. Your job is to find out the age of the ghost who was awarded
with the "Consistency Trophy" on each day of the competition.


#include<bits/stdc++.h>
using namespace std;
#define ll long long int
int main()
{
    ll t,i,j,k,l,n,m;
    cin>>n>>m;
    priority_queue<pair<ll,ll>>p;
    ll a[n+3];
    unordered_map<ll,ll>h;
    for(i=0;i<n;i++)
        cin>>a[i];
    for(i=0;i<n;i++)
    {
        //cin>>a[i];
        h[a[i]]++;
        p.push({h[a[i]],a[i]});
        cout<<p.top().second<<" "<<p.top().first<<endl;
    }
    return 0;
}

Input:
7 5
1 3 1 3 2 2 2

Output:
1 1
3 1
1 2
3 2
3 2
2 3
